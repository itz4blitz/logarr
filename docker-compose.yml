services:
  db:
    image: postgres:16-alpine
    container_name: logarr-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: logarr
    ports:
      - '5433:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres']
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - logarr-network

  redis:
    image: redis:7-alpine
    container_name: logarr-redis
    restart: unless-stopped
    ports:
      - '6380:6379'
    volumes:
      - redis_data:/data
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - logarr-network

  backend:
    build:
      context: .
      dockerfile: apps/backend/Dockerfile
    container_name: logarr-backend
    restart: unless-stopped
    ports:
      - '${BACKEND_PORT:-4001}:4000'
    environment:
      NODE_ENV: production
      DATABASE_URL: postgresql://postgres:postgres@db:5432/logarr
      REDIS_URL: redis://redis:6379
      BACKEND_PORT: 4000
      CORS_ORIGIN: ${CORS_ORIGIN:-http://localhost:3001}
      # Health check startup grace period (seconds) - allows file ingestion to initialize
      # Volume mounts may not be immediately available after docker compose restart
      HEALTH_CHECK_STARTUP_GRACE_SECONDS: ${HEALTH_CHECK_STARTUP_GRACE_SECONDS:-60}
      # AI Providers (auto-configured on startup if set)
      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY:-}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      GOOGLE_AI_API_KEY: ${GOOGLE_AI_API_KEY:-}
      OLLAMA_BASE_URL: ${OLLAMA_BASE_URL:-}
      LMSTUDIO_BASE_URL: ${LMSTUDIO_BASE_URL:-}
      # Media Servers (auto-configured on startup if set)
      JELLYFIN_URL: ${JELLYFIN_URL:-}
      JELLYFIN_API_KEY: ${JELLYFIN_API_KEY:-}
      PLEX_URL: ${PLEX_URL:-}
      PLEX_TOKEN: ${PLEX_TOKEN:-}
      EMBY_URL: ${EMBY_URL:-}
      EMBY_API_KEY: ${EMBY_API_KEY:-}
      SONARR_URL: ${SONARR_URL:-}
      SONARR_API_KEY: ${SONARR_API_KEY:-}
      RADARR_URL: ${RADARR_URL:-}
      RADARR_API_KEY: ${RADARR_API_KEY:-}
      PROWLARR_URL: ${PROWLARR_URL:-}
      PROWLARR_API_KEY: ${PROWLARR_API_KEY:-}
      WHISPARR_URL: ${WHISPARR_URL:-}
      WHISPARR_API_KEY: ${WHISPARR_API_KEY:-}
      # Log paths - set to non-empty to enable file ingestion for that server
      # The actual path inside container is fixed (e.g., /jellyfin-logs)
      JELLYFIN_LOGS_PATH: ${JELLYFIN_LOGS_PATH:-}
      PLEX_LOGS_PATH: ${PLEX_LOGS_PATH:-}
      EMBY_LOGS_PATH: ${EMBY_LOGS_PATH:-}
      SONARR_LOGS_PATH: ${SONARR_LOGS_PATH:-}
      RADARR_LOGS_PATH: ${RADARR_LOGS_PATH:-}
      PROWLARR_LOGS_PATH: ${PROWLARR_LOGS_PATH:-}
      WHISPARR_LOGS_PATH: ${WHISPARR_LOGS_PATH:-}
      # Multiple instance support - add numbered suffixes for additional instances
      # Example: RADARR_LOGS_PATH_1=/path/to/movies, RADARR_LOGS_PATH_2=/path/to/shorts
      JELLYFIN_LOGS_PATH_1: ${JELLYFIN_LOGS_PATH_1:-}
      JELLYFIN_LOGS_PATH_2: ${JELLYFIN_LOGS_PATH_2:-}
      JELLYFIN_LOGS_PATH_3: ${JELLYFIN_LOGS_PATH_3:-}
      PLEX_LOGS_PATH_1: ${PLEX_LOGS_PATH_1:-}
      PLEX_LOGS_PATH_2: ${PLEX_LOGS_PATH_2:-}
      PLEX_LOGS_PATH_3: ${PLEX_LOGS_PATH_3:-}
      EMBY_LOGS_PATH_1: ${EMBY_LOGS_PATH_1:-}
      EMBY_LOGS_PATH_2: ${EMBY_LOGS_PATH_2:-}
      EMBY_LOGS_PATH_3: ${EMBY_LOGS_PATH_3:-}
      SONARR_LOGS_PATH_1: ${SONARR_LOGS_PATH_1:-}
      SONARR_LOGS_PATH_2: ${SONARR_LOGS_PATH_2:-}
      SONARR_LOGS_PATH_3: ${SONARR_LOGS_PATH_3:-}
      RADARR_LOGS_PATH_1: ${RADARR_LOGS_PATH_1:-}
      RADARR_LOGS_PATH_2: ${RADARR_LOGS_PATH_2:-}
      RADARR_LOGS_PATH_3: ${RADARR_LOGS_PATH_3:-}
      PROWLARR_LOGS_PATH_1: ${PROWLARR_LOGS_PATH_1:-}
      PROWLARR_LOGS_PATH_2: ${PROWLARR_LOGS_PATH_2:-}
      PROWLARR_LOGS_PATH_3: ${PROWLARR_LOGS_PATH_3:-}
      WHISPARR_LOGS_PATH_1: ${WHISPARR_LOGS_PATH_1:-}
      WHISPARR_LOGS_PATH_2: ${WHISPARR_LOGS_PATH_2:-}
      WHISPARR_LOGS_PATH_3: ${WHISPARR_LOGS_PATH_3:-}
    volumes:
      # Media server log mounts (optional - set paths in .env for file-based log ingestion)
      # In the Sources UI, configure paths as: /plex-logs, /jellyfin-logs, /emby-logs, etc.
      - ${PLEX_LOGS_PATH:-/dev/null}:/plex-logs:ro
      - ${JELLYFIN_LOGS_PATH:-/dev/null}:/jellyfin-logs:ro
      - ${EMBY_LOGS_PATH:-/dev/null}:/emby-logs:ro
      - ${SONARR_LOGS_PATH:-/dev/null}:/sonarr-logs:ro
      - ${RADARR_LOGS_PATH:-/dev/null}:/radarr-logs:ro
      - ${PROWLARR_LOGS_PATH:-/dev/null}:/prowlarr-logs:ro
      - ${WHISPARR_LOGS_PATH:-/dev/null}:/whisp-logs:ro
      # Multiple instance mounts - numbered instances map to /<server>-logs-<n>
      - ${JELLYFIN_LOGS_PATH_1:-/dev/null}:/jellyfin-logs-1:ro
      - ${JELLYFIN_LOGS_PATH_2:-/dev/null}:/jellyfin-logs-2:ro
      - ${JELLYFIN_LOGS_PATH_3:-/dev/null}:/jellyfin-logs-3:ro
      - ${PLEX_LOGS_PATH_1:-/dev/null}:/plex-logs-1:ro
      - ${PLEX_LOGS_PATH_2:-/dev/null}:/plex-logs-2:ro
      - ${PLEX_LOGS_PATH_3:-/dev/null}:/plex-logs-3:ro
      - ${EMBY_LOGS_PATH_1:-/dev/null}:/emby-logs-1:ro
      - ${EMBY_LOGS_PATH_2:-/dev/null}:/emby-logs-2:ro
      - ${EMBY_LOGS_PATH_3:-/dev/null}:/emby-logs-3:ro
      - ${SONARR_LOGS_PATH_1:-/dev/null}:/sonarr-logs-1:ro
      - ${SONARR_LOGS_PATH_2:-/dev/null}:/sonarr-logs-2:ro
      - ${SONARR_LOGS_PATH_3:-/dev/null}:/sonarr-logs-3:ro
      - ${RADARR_LOGS_PATH_1:-/dev/null}:/radarr-logs-1:ro
      - ${RADARR_LOGS_PATH_2:-/dev/null}:/radarr-logs-2:ro
      - ${RADARR_LOGS_PATH_3:-/dev/null}:/radarr-logs-3:ro
      - ${PROWLARR_LOGS_PATH_1:-/dev/null}:/prowlarr-logs-1:ro
      - ${PROWLARR_LOGS_PATH_2:-/dev/null}:/prowlarr-logs-2:ro
      - ${PROWLARR_LOGS_PATH_3:-/dev/null}:/prowlarr-logs-3:ro
      - ${WHISPARR_LOGS_PATH_1:-/dev/null}:/whisp-logs-1:ro
      - ${WHISPARR_LOGS_PATH_2:-/dev/null}:/whisp-logs-2:ro
      - ${WHISPARR_LOGS_PATH_3:-/dev/null}:/whisp-logs-3:ro
    healthcheck:
      test: ['CMD', 'wget', '--no-verbose', '--tries=1', '--spider', 'http://localhost:4000/api']
      interval: 30s
      timeout: 10s
      retries: 3
      # Increased start_period to accommodate file ingestion initialization
      # Combined with HEALTH_CHECK_STARTUP_GRACE_SECONDS, this prevents false failures during restart
      start_period: 90s
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - logarr-network

  frontend:
    build:
      context: .
      dockerfile: apps/frontend/Dockerfile
    container_name: logarr-frontend
    restart: unless-stopped
    ports:
      - '${FRONTEND_PORT:-3001}:3000'
    environment:
      NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-http://localhost:4001/api}
      NEXT_PUBLIC_WS_URL: ${NEXT_PUBLIC_WS_URL:-ws://localhost:4001}
    healthcheck:
      test: ['CMD', 'wget', '--no-verbose', '--tries=1', '--spider', 'http://localhost:3000']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - logarr-network

volumes:
  postgres_data:
  redis_data:

networks:
  logarr-network:
    driver: bridge
